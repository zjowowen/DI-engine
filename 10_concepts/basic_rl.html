


<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!-->
<html class="no-js" lang="en">
<!--<![endif]-->

<head>
  <meta charset="utf-8">
  <meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Basic Concepts &mdash; DI-engine 0.1.0 documentation</title>
  

  <link rel="shortcut icon" href="../_static/images/favicon.ico" />
  
  

  

  
  
  

  

  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <!-- <link rel="stylesheet" href="../_static/pygments.css" type="text/css" /> -->
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/style.css" type="text/css" />
  <link rel="index" title="Index" href="../genindex.html" />
  <link rel="search" title="Search" href="../search.html" />
  <link rel="next" title="Learn From DI-zoo" href="../11_dizoo/index.html" />
  <link rel="prev" title="Introduction to RL" href="index.html" />
    <link href="../_static/css/style.css" rel="stylesheet" type="text/css">


  
  <script src="../_static/js/modernizr.min.js"></script>
  <script>
    MathJax = {
        chtml: {
            scale: 1,
            minScale: 1,
        },
        svg: {
            scale: 1,
            minScale: 1,
        }
    }
</script>

  <!-- Preload the theme fonts -->

<link rel="preload" href="../_static/fonts/FreightSans/freight-sans-book.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="../_static/fonts/FreightSans/freight-sans-medium.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="../_static/fonts/IBMPlexMono/IBMPlexMono-Medium.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="../_static/fonts/FreightSans/freight-sans-bold.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="../_static/fonts/FreightSans/freight-sans-medium-italic.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="../_static/fonts/IBMPlexMono/IBMPlexMono-SemiBold.woff2" as="font" type="font/woff2" crossorigin="anonymous">

<!-- Preload the katex fonts -->

<link rel="preload" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/fonts/KaTeX_Math-Italic.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/fonts/KaTeX_Main-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/fonts/KaTeX_Main-Bold.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/fonts/KaTeX_Size1-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/fonts/KaTeX_Size4-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/fonts/KaTeX_Size2-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/fonts/KaTeX_Size3-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/fonts/KaTeX_Caligraphic-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"
    integrity="sha384-vSIIfh2YWi9wW0r9iZe7RJPrKwp6bG+s9QZMoITbCckVJqGCCRhc+ccxNcdpHuYu" crossorigin="anonymous">
</head>

<div class="container-fluid header-holder tutorials-header" id="header-holder">
  <div class="container">
    <div class="header-container">
      <a class="header-logo" href="https://di-engine-docs.readthedocs.io/en/latest/"
        aria-label="OpenMMLab"></a>

      <div class="main-menu">
        <ul>
          <li>
            <a href="https://github.com/opendilab/DI-engine" target="_blank">GitHub</a>
          </li>
          <li >
            <div id="resourcesDropdownButton" data-toggle="resources-dropdown" class="resources-dropdown">
              <a
                class="resource-option with-down-arrow">
                OpenDILab
              </a>
              <div class="resources-dropdown-menu">
                <a class="doc-dropdown-option nav-dropdown-item"
                  href="https://github.com/opendilab/DI-engine" target="_blank">
                  <span class="dropdown-title">DI-engine </span>
                  <p>OpenDILab Decision AI Engine</p>
                </a>
                <a class="doc-dropdown-option nav-dropdown-item"
                  href="https://github.com/opendilab/DI-star" target="_blank">
                  <span class="dropdown-title">DI-star </span>
                  <p>OpenDILab Decision AI in StarCraftII</p>
                </a>
                <a class="doc-dropdown-option nav-dropdown-item"
                  href="https://github.com/opendilab/DI-drive" target="_blank">
                  <span class="dropdown-title">DI-drive </span>
                  <p>OpenDILab Auto-driving platform</p>
                </a>
                <a class="doc-dropdown-option nav-dropdown-item"
                  href="https://github.com/opendilab/GoBigger" target="_blank">
                  <span class="dropdown-title">GoBigger </span>
                  <p>OpenDILab Multi-Agent Environment</p>
                </a>
                <a class="doc-dropdown-option nav-dropdown-item"
                  href="https://github.com/opendilab/DI-smartcross" target="_blank">
                  <span class="dropdown-title">DI-smartcross </span>
                  <p>Decision Intelligence Platform for Traffic Crossing Signal Control</p>
                </a>
                <a class="doc-dropdown-option nav-dropdown-item"
                  href="https://github.com/opendilab/DI-treetensor" target="_blank">
                  <span class="dropdown-title">DI-treetensor </span>
                  <p>Tree Nested PyTorch Tensor Lib</p>
                </a>
                <a class="doc-dropdown-option nav-dropdown-item"
                  href="https://github.com/opendilab/awesome-model-based-RL" target="_blank">
                  <span class="dropdown-title">awesome-model-based-RL </span>
                  <p>A curated list of awesome model based RL resources (continually updated)</p>
                </a>
              </div>
          </li>
        </ul>
      </div>

      <a class="main-menu-open-button" href="#" data-behavior="open-mobile-menu"></a>
    </div>
  </div>
</div>

<body class="pytorch-body">

   

  

  <div class="table-of-contents-link-wrapper">
    <span>Table of Contents</span>
    <a href="#" class="toggle-table-of-contents" data-behavior="toggle-table-of-contents"></a>
  </div>

  <nav data-toggle="wy-nav-shift" class="pytorch-left-menu" id="pytorch-left-menu">
    <div class="pytorch-side-scroll">
      <div class="pytorch-menu pytorch-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
        <div class="pytorch-left-menu-search">
          

          
          
          
          

          



<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search Docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        
        
        
        
        
        <p class="caption" role="heading"><span class="caption-text">User Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../00_intro/index.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../01_quickstart/index.html">Quickstart</a></li>
<li class="toctree-l1"><a class="reference internal" href="../02_algo/index.html">RL Algorithm Taxonomy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../03_system/index.html">System Design</a></li>
<li class="toctree-l1"><a class="reference internal" href="../05_api_doc/index.html">API Doc</a></li>
<li class="toctree-l1"><a class="reference internal" href="../06_faq/index.html">FAQ</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Reinforcement Learning Tutorial</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Introduction to RL</a></li>
<li class="toctree-l1"><a class="reference internal" href="../11_dizoo/index.html">Learn From DI-zoo</a></li>
<li class="toctree-l1"><a class="reference internal" href="../12_policies/index.html">RL Algorithms Cheat Sheet</a></li>
<li class="toctree-l1"><a class="reference internal" href="../13_envs/index.html">RL Env Examples</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Developer Specification</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../20_spec/index.html">Specification</a></li>
<li class="toctree-l1"><a class="reference internal" href="../21_code_style/index.html">Code Style Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../22_test/index.html">Unit Test Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../23_visual/index.html">Diagrams and Visualization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../24_cooperation/index.html">Github Cooperation</a></li>
</ul>

        
        
      </div>
    </div>
  </nav>

  <div class="pytorch-container">
    <div class="pytorch-page-level-bar" id="pytorch-page-level-bar">
      <div class="pytorch-breadcrumbs-wrapper">
        















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="pytorch-breadcrumbs">
    
      <li>
        <a href="../index.html">
            Docs
        </a> &gt;
      </li>

        
          <li><a href="index.html">Introduction to RL</a> &gt;</li>
        
      <li>Basic Concepts</li>
    
    
      <li class="pytorch-breadcrumbs-aside">
        
            
            <a href="../_sources/10_concepts/basic_rl.rst.txt" rel="nofollow"><img src="../_static/images/view-page-source-icon.svg"></a>
          
        
      </li>
    
  </ul>

  
</div>
      </div>

      <div class="pytorch-shortcuts-wrapper" id="pytorch-shortcuts-wrapper">
        Shortcuts
      </div>
    </div>

    <section data-toggle="wy-nav-shift" id="pytorch-content-wrap" class="pytorch-content-wrap">
      <div class="pytorch-content-left">
        
          <div class="rst-content">
            
            <div role="main" class="main-content" itemscope="itemscope" itemtype="http://schema.org/Article">
              <article itemprop="articleBody" id="pytorch-article" class="pytorch-article">
                
  <section id="basic-concepts">
<h1>Basic Concepts<a class="headerlink" href="#basic-concepts" title="Permalink to this headline">¶</a></h1>
<p>Reinforcement learning (RL) has been used to solve the interaction problem between agents and environments. The interaction process can be simply described as follows: An agent receives observation from the environment, and acts accordingly. The environment will change due to the action taken by the agent and send a reward to the agent. This process runs repeatedly and the goal of the agent is to maximize the cumulative reward (sum of (discounted) rewards) received. The objective of reinforcement learning is to enable agents to learn strategies which we call ‘policy’ and maximize the cumulative reward.</p>
<p>To have a basic understanding for reinforcement learning, we explain the following basic concepts：</p>
<ul class="simple">
<li><p>Markov Decision Processes</p></li>
<li><p>State and action spaces</p></li>
<li><p>Policy</p></li>
<li><p>Trajectory</p></li>
<li><p>Return and reward</p></li>
</ul>
<p>To understand reinforcement learning better, we further explain the following concepts:</p>
<ul class="simple">
<li><p>RL optimization problem</p></li>
<li><p>Value function</p></li>
<li><p>Policy gradients</p></li>
<li><p>Actor Critic</p></li>
<li><p>Model-based RL</p></li>
</ul>
<p>In the end, we will list and answer some common questions raised in the domain of reinforcement learning for reference.</p>
<section id="markov-decision-process-mdp">
<h2>Markov Decision Process/MDP<a class="headerlink" href="#markov-decision-process-mdp" title="Permalink to this headline">¶</a></h2>
<p><strong>Markov Decision Process (MDP)</strong> is the ideal mathematical model of reinforcement learning and the commonest one.</p>
<ul class="simple">
<li><p>Markov property：State <span class="math notranslate nohighlight">\(s_t\)</span> is Markov, iff <span class="math notranslate nohighlight">\(P[s_{t+1}|s_t] = P[s_{t+1}|s_1, ..., s_t]\)</span> .</p></li>
<li><p>A Markov process is a memoryless random process, i.e., a sequence of random states S_1,　S_2… with the Markov process.</p></li>
<li><p>Markov process is a binary tuple <span class="math notranslate nohighlight">\((S, P)\)</span> , satisfying: <span class="math notranslate nohighlight">\(S\)</span> a finite set of states, <span class="math notranslate nohighlight">\(P\)</span> is a probability transition matrix. There are no rewards or actions in a Markov process. A Markov process that takes actions and rewards into account is called an MDP.</p></li>
<li><p>MDP is a tuple <span class="math notranslate nohighlight">\((S, A, P, R, \gamma)\)</span>， <span class="math notranslate nohighlight">\(S\)</span> is a finite set of states, <span class="math notranslate nohighlight">\(A\)</span> is a finite set of actions， <span class="math notranslate nohighlight">\(P\)</span> is a state transition probability matrix, <span class="math notranslate nohighlight">\(R\)</span> is a reward function， <span class="math notranslate nohighlight">\(\gamma\)</span> is a discount factor used to calculate the accumulated rewards. Unlike the Markov process, the state transfer probability of the Markov decision process is <span class="math notranslate nohighlight">\(P(s_{t+1}|s_t, a_t)\)</span> . <span class="math notranslate nohighlight">\(P(s_{t+1}|s_t, a_t)\)</span> .</p></li>
<li><p>The goal of reinforcement learning is to seek an optimal policy based on an MDP.  The so-called policy <span class="math notranslate nohighlight">\(\pi(a|s)\)</span> refers to the mapping of states to actions. In reinforcement learning, we only discuss Markov decision processes with finite state space.</p></li>
</ul>
<p>Common methods for solving MDP problems:</p>
<ol class="arabic">
<li><p><strong>Dynamic programming (DP)</strong> is an optimization method that can compute the optimal policy given an MDP. However, for reinforcement learning problems, traditional DP is of limited use and prone to dimensional catastrophe problems.</p>
<p>DP has the following characteristics:</p>
<ul class="simple">
<li><p>Updating is based on currently existing estimates: the value estimate of a current state is updated with the value estimate of each of its subsequent states</p></li>
<li><p>Asymptotic convergence</p></li>
<li><p>Advantages: reduced variance and faster learning</p></li>
<li><p>Disadvantages: bias dependent on the quality of the function approximation</p></li>
</ul>
</li>
<li><p><strong>Monte Carlo methods (MC)</strong>  are based directly on the definition of the optimal value function and provide an unbiased estimate of the optimal value function by sampling. MC replaces the actual expected return with the sample return and solves the optimal strategy empirically only.</p>
<p>MC does not need an environmental model. Data simulation and sampling models can be applied to MC and MC can only evaluate a certain state of interest. In comparison with DP, MC performs better when the Markov property does not hold.</p>
</li>
<li><p><strong>Temperal-Differnece learning (TD)</strong>, TD error: <span class="math notranslate nohighlight">\(\delta_{t} = R_{t+1} + \gamma V(S_{t+1}) - V(S_t)\)</span></p>
<p>Comparison between TD and MC: The target for MC is <span class="math notranslate nohighlight">\(G_t\)</span>, namely, the real return from time t onwards. However, the target for TD (single step TD, TD(0)) is  <span class="math notranslate nohighlight">\(R_{t+1} + \gamma V(S_{t+1})\)</span> .</p>
</li>
</ol>
</section>
<section id="state-spaces">
<h2>State Spaces<a class="headerlink" href="#state-spaces" title="Permalink to this headline">¶</a></h2>
<p>State <span class="math notranslate nohighlight">\(s\)</span> is a global description of the environment，observation <span class="math notranslate nohighlight">\(o\)</span> is a partial description of the environment. States and observations from an environment can be represented by real vectors, matrices or tensors. For example, RGB pictures are used in Atari games to represent information about the game environment, and vectors are used in MuJoCo control tasks to represent the state of an intelligent body.</p>
<p>When an agent can receive all information of states in an environment <span class="math notranslate nohighlight">\(s\)</span> ，we call its learning process fully observable. When an agent can only receive partial information of states in an environment <span class="math notranslate nohighlight">\(o\)</span>，we call its learning process partially observable，namely, partially observable Markov decision processes (POMDP) <span class="math notranslate nohighlight">\((O, A, P, R, \gamma)\)</span>.</p>
</section>
<section id="action-spaces">
<h2>Action Spaces<a class="headerlink" href="#action-spaces" title="Permalink to this headline">¶</a></h2>
<p>Different environments allow different action spaces. The set of all valid actions <span class="math notranslate nohighlight">\(a\)</span> in an environment is generally referred to as the Action Space. The action space can be classified into a discrete action space or a continuous action space.</p>
<p>For example, in Atari games and SMAC games, the action spaces are both discrete and only a limited number of actions can be selected from each space. However, in some robot continuous control tasks such as MuJoCo, the action space is continuous and generally belongs to a real-valued vector interval.</p>
</section>
<section id="policy">
<h2>Policy<a class="headerlink" href="#policy" title="Permalink to this headline">¶</a></h2>
<p><strong>Policy</strong> determines actions an agent takes when facing different states. If a policy is deterministic, it is usually denoted by <span class="math notranslate nohighlight">\(a_t = \mu(s_t)\)</span> .
when a policy is stochastic，it is usually denoted by <span class="math notranslate nohighlight">\(a_t ~ \pi(·｜s_t')\)</span>.</p>
<p>In reinforcement learning，the policy gradient approach requires learning a parametric representation of the policy (parameterized policy) by fitting a policy function with parameters. <span class="math notranslate nohighlight">\(\theta\)</span> is often used as the parameters. Another approach based on value functions does not necessarily require a policy gradient function. In the following sections, we describe in a more detailed approach to learning policies in reinforcement learning.</p>
</section>
<section id="trajectory">
<h2>Trajectory<a class="headerlink" href="#trajectory" title="Permalink to this headline">¶</a></h2>
<p>In reinforcement learning, a sample learning sequence in an MDP is called <strong>trajectory</strong> <span class="math notranslate nohighlight">\((s_0, a_0, ..., s_n, a_n)\)</span>. Trajectory data includes a state transition function，namely, <span class="math notranslate nohighlight">\(s_{t+1} = f(s_t, a_t)\)</span> and a policy followed by the agents. Reinforcement learning contains two parts: how to use the policy to sample the trajectory data and how to use the trajectory data to update the learning target. The difference between the two components creates a difference in reinforcement learning methods.</p>
<p>As the trajectory also contains information about the dynamics of the model in the environment, it is possible to use the policy data to learn information about the environment as well, which can be used to help the learning of the intelligence. </p>
<p>Note that the transition function can be deterministic or stochastic. In a grid world, the transition function is deterministic, i.e., an agent is going to go to a certain state given its current state and action. On the contrary, the state function is stochastic if an agent’s current state and action are given, but the agent may end up with more than one state with each probability smaller than one. A stochastic state function is random in nature and cannot be determined completely by an agent.
This case can be easily illustrated in a simple MDP environment.</p>
</section>
<section id="return-and-reward">
<h2>Return and reward<a class="headerlink" href="#return-and-reward" title="Permalink to this headline">¶</a></h2>
<p><strong>Reward</strong> is a learning signal assigned to an agent by its surrounding environment. When the environment changes，the reward function also changes. The reward function is determined by the current state and the action taken by the agent，and can be written as <span class="math notranslate nohighlight">\(r_t = R(s_t, a_t)\)</span></p>
<p><strong>Cumulative Reward</strong> is the sum of the decaying returns from moment t onwards in an MDP.</p>
<p><span class="math notranslate nohighlight">\(G_t = R_{t+1}+\gamma * R_{t+2}+{\gamma}^2 * R_{t+3}+ ...\)</span></p>
<p><span class="math notranslate nohighlight">\(\gamma\)</span> The discount factor reflects the ratio between the value of future rewards and that at the present moment. A value close to 0 indicates a tendency towards a ‘myopic’ assessment and a value close to indicates a more forward-looking interest and confidence in the future. The introduction of the discount factor is not only easy to express mathematically, but also avoids falling into an infinite loop and reduces the uncertainty of future benefits.</p>
<p>Other difficulties in dealing with reward functions may exist in different environments, such as sparse rewards where the environment does not give feedback in every state and only acquires rewards after a period of trajectory has elapsed. Therefore, the design and processing of reward functions in reinforcement learning are important directions that have a significant impact on the effectiveness of reinforcement learning.</p>
</section>
<section id="rl-optimization-problem">
<h2>RL optimization problem<a class="headerlink" href="#rl-optimization-problem" title="Permalink to this headline">¶</a></h2>
<p>In simple terms, the goal of a reinforcement learning problem is to find a policy that maximizes the expected total reward. Then, if we can calculate the return after each state by taking some action, we only need to take the action with the higher reward or the action that will lead to the states with the higher reward. Thus, the estimation of expected reward is also an optimization direction for reinforcement learning. Another approach is to search directly over the action space. In either case, the ultimate optimization goal is to maximize the reward.</p>
</section>
<section id="value-functions">
<h2>Value functions<a class="headerlink" href="#value-functions" title="Permalink to this headline">¶</a></h2>
<p><strong>State Value Function</strong> refers to a long-term expected reward by following a policy <span class="math notranslate nohighlight">\(\pi\)</span> under a state <span class="math notranslate nohighlight">\(s\)</span> . The state value function is one of the criteria for evaluating a policy function</p>
<p><span class="math notranslate nohighlight">\(V_{\pi}(s) = E_{\pi}[G_t|s_t=s]\)</span></p>
<p><strong>Action Value Function</strong> refers to a long-term expected reward by following a policy <span class="math notranslate nohighlight">\(\pi\)</span> under a state <span class="math notranslate nohighlight">\(s\)</span> ,  and an action <span class="math notranslate nohighlight">\(a\)</span></p>
<p><span class="math notranslate nohighlight">\(Q_{\pi}(s, a) = E_{\pi}[G_t|s_t=s, a_t=a]\)</span></p>
<p>The relationship between the state-valued function and the action-valued function：</p>
<p><span class="math notranslate nohighlight">\(V_{\pi}(s) = \sum \pi(a|s)Q_{\pi}(s,a)\)</span></p>
<p>We can further obtain the relationship between the optimal state value function and the optimal behavioral value function as follows.</p>
<p><span class="math notranslate nohighlight">\(V*(s)=max_a Q*(s, a)\)</span></p>
<p><strong>Bellman Equations</strong>，The Bellman’s equation is the basis of reinforcement learning. The Bellman equation represents the value of the current state in relation to the value of the next state, and the current reward.
We can express the state value function and the action value function as:</p>
<p><span class="math notranslate nohighlight">\(V_{\pi}(s) = E_{\pi}[R_{t+1}+\gamma * v_{\pi}(s_{t+1})|s_t=s]\)</span></p>
<p><span class="math notranslate nohighlight">\(Q_{\pi}(s, a) = E_{\pi}[R_{t+1}+\gamma * Q(s_{t+1},a_{t+1})|s_t=s, a_t=a]\)</span></p>
<p><strong>Bellman Optimality Equations</strong>，</p>
<p><span class="math notranslate nohighlight">\(V*(s)=E[R_{t+1} + \gamma * max_{\pi}V(s_{t+1})|s_t=s]\)</span></p>
<p><span class="math notranslate nohighlight">\(Q*(s, a) = E_{\pi}[R_{t+1}+\gamma * max_{a'}Q(s_{t+1},a')|s_t=s, a_t=a]\)</span></p>
<p>Value based reinforcement learning approach includes two steps：policy evaluation and policy improvement. Reinforcement learning first estimate the value function based on the policy，then, improves the policy according to the value function. When the value function reaches the optima, the policy is considered as the optimal policy. This optimal policy is a greedy policy.</p>
<p>For systems where the model is known, the value function can be obtained using DPs; For systems where the model is unknown, it can be obtained using MC or TD.</p>
<p>For a grid reinforcement learning environment，the estimation of the value function is obtained by iteratively updating the table of value functions. In many cases，say, state space and action space are not discrete，the value function cannot be represented by a table. In this situation, we need to take advantage of function approximation to approximate the value function.</p>
</section>
<section id="policy-gradients">
<h2>Policy Gradients<a class="headerlink" href="#policy-gradients" title="Permalink to this headline">¶</a></h2>
<p>In some situations，a stocatic policy is better than a deterministic policy. As a result, value-based reinforcement learning cannot learn such policy and a policy-based approach to reinforcement learning is therefore proposed.</p>
<p>Unlike value-based reinforcement learning, policy-based reinforcement learning parameterises the policy and represent it by using linear or non-linear functions to find the optimal parameters that maximize the expectation of the cumulative reward, the goal of reinforcement learning.</p>
<p>In the value-based approach, we iteratively compute the value function and then improve the policy based on the value function, whereas in the policy search approach, we directly compute the policy iteration using <strong>policy gradient</strong>, i.e. we compute the policy gradient on the action, and iteratively update the policy parameter values along the gradient until the expectation of cumulative return is maximzed, at which point the policy corresponding to the parameter is the optimal policy.</p>
<p>Compared to the value-based approach, the policy gradient reinforcement learning tends to converge to a local minimum, which is not sufficient when evaluating an individual policy and has a large variance.</p>
<p>For a more detailed understanding of the policy based approach, please refer to the specific algorithms in our documentation：　<a class="reference external" href="../hands_on/index.html">Hans On
RL</a></p>
</section>
<section id="actor-critic">
<h2>Actor Critic<a class="headerlink" href="#actor-critic" title="Permalink to this headline">¶</a></h2>
<p><strong>Critic</strong>, parametrized behavioral value function; performs the value evaluation of the policy.</p>
<p><strong>Actor</strong>, parametrized policy function, performs an update of the policy function parameters using the policy gradient according to the value obtained in the Critic part.</p>
<p>In summary, Actor Critic is an approach that learns both the value function and the policy function, combining the advantages of both of these approaches. Various algorithms based on this framework can adapt to problems in different action and state spaces as well as to find optimal policies in different policy spaces.</p>
<p>More Actor Critic algorithms such as A2C, DDPG, TD3, etc. are explained in our documentation.</p>
</section>
<section id="model-based-rl">
<h2>Model-based RL<a class="headerlink" href="#model-based-rl" title="Permalink to this headline">¶</a></h2>
<p>Of the above model-free approaches, the value-based approach learns the value function (MC or TD) before updating the policy, while the policy-based approach updates the policy directly. The model-based approach focuses on the environment dynamics, where a model of the environment is learned through sampling, and then the value function/ policy is optimized based on the learned environment model.</p>
<p>Once the modeling of the environment has been completed, there are also two paths in the model-based approach: one is to generate some simulation trajectories from the learned model and estimate the value function from the simulation trajectories to optimise the strategy; the other is to optimize the policy directly from the learned model, which is the route the model-based approach is usually taking. Learning a model of the environment first can help us to solve the problem of sample efficiency in reinforcement learning methods.</p>
<p>The definition of a model can be expressed mathematically as a tuple of state transfer distributions and reward functions.</p>
<p><span class="math notranslate nohighlight">\(M=(P,R), s_{t+1}~P(s_{t+1}|s_t, a_t), r_{t+1}~R(r_{t+1}|s_t, a_t)\)</span></p>
<p>The learning of a model can be extended to different algorithms depending on the model construction.</p>
<p>Model-based policy optimization: A classical approach is to first sample a large amount of data by some strategy, then learn a model to minimize the error, apply the learned model to planning to obtain new data, and repeat the above steps. It is by doing planning on top of the learned model that model-based improves the efficiency of the entire iteration of the reinforcement learning algorithm.</p>
</section>
<section id="q-a">
<h2>Q&amp;A<a class="headerlink" href="#q-a" title="Permalink to this headline">¶</a></h2>
<dl class="simple">
<dt>Q1: What are model-based and model-free methods，what are the differences？Which category should MC、TD、DP, etc. belong to?</dt><dd><ul class="simple">
<li><p>Answer：
model based algorithm means that the algorithm learns the state transition process of the environment and models the environment, whereas a model free algorithm does not require the environment to be modeled.
Monte Carlo and TD algorithms are model-free because they do not require the algorithm to model a specific environment.
Dynamic programming, on the other hand, is model-based, as the use of dynamic programming requires a complete model of the environment.</p></li>
</ul>
</dd>
<dt>Q2: What do we mean by value-based， policy-based and collector-critic？ which algorithms can be classified as value-based，policy-based or actor-critic？what advantages do they have？what about the disadvantages？</dt><dd><ul class="simple">
<li><p>Answer：Value-based is to learn how to do critic (judging the value of an input state). Policy-based is to learn how to do actor (judging what action should be taken in an input state), and actor-critic is to learn decide critic while training the actor network.
The relationship of these three classes can be well explained by the following diagram.</p></li>
</ul>
</dd>
</dl>
<a class="reference internal image-reference" href="../_images/actor-critic.jpg"><img alt="../_images/actor-critic.jpg" src="../_images/actor-critic.jpg" style="width: 527.1px; height: 228.6px;" /></a>
<dl class="simple">
<dt>Q3: What are on-policy and off-policy？</dt><dd><ul class="simple">
<li><p>Answer：The on-policy algorithms are trained using the current policy. The policy used to generate sampled data is the same as the policy to be evaluated and improved.
Off-policy algorithm, on the other hand, can be trained using the policy from the previous process, and the policy used to generate the sampled data is different from the policy to be evaluated and improved, i.e., the data generated is “off” the trajectory of the decision series determined by the policy to be optimised.
On-policy and off-policy simply mean how training is done, and sometimes an algorithm may even have different ways of  implementation of on-policy and off-policy.</p></li>
</ul>
</dd>
<dt>Q4: What are online training and offline training？ How do we implement offline training？</dt><dd><ul class="simple">
<li><p>Answer： Offline training means the training uses fixed datasets as input  instead of using a collector to interact with the environment. For example, behavioral cloning is a classic offline training algorithm. We usually input batch data in a fixed dataset, hence, offline RL is also called batch RL.</p></li>
</ul>
</dd>
<dt>Q5: What are exploration and exploitation？What methods do we use to balance exploration and exploitation？</dt><dd><ul class="simple">
<li><p>Answer：Exploration is when an agent in RL is constantly exploring different states of the environment, while exploitation is when the agent selects the most rewarding action possible for the current state.
There are many ways to balance exploration and exploitation. There are also different ways of implementation in different algorithms. With respect to sampling in discrete action spaces, one can follow a probability distribution or select randomly. With respect to sampling in continuous action spaces, one can follow a continuous distribution or add NOISE.</p></li>
</ul>
</dd>
<dt>Q6: Why do we use replay buffer？ why do we need experience replay？</dt><dd><ul class="simple">
<li><p>Answer：By using the replay buffer, we can store the experiences in the buffer and sample the experiences in the buffer during subsequent training. Experience replay is a technique that saves samples from the system’s exploration of the environment and then samples them to update the model parameters.</p></li>
</ul>
</dd>
</dl>
</section>
</section>


              </article>
              
            </div>
            <footer>
  
  <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
    
    <a href="../11_dizoo/index.html" class="btn btn-neutral float-right" title="Learn From DI-zoo" accesskey="n"
      rel="next">Next <img src="../_static/images/chevron-right-blue.svg"
        class="next-page"></a>
    
    
    <a href="index.html" class="btn btn-neutral" title="Introduction to RL" accesskey="p"
      rel="prev"><img src="../_static/images/chevron-right-blue.svg" class="previous-page"> Previous</a>
    
  </div>
  

  <hr>

  <div role="contentinfo">
    <p>
      &copy; Copyright 2021, OpenDILab Contributors.

    </p>
  </div>
  
  <div>
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a
      href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the
      Docs</a>.
  </div>
   

</footer>
          </div>
        </div>

        <div class="pytorch-content-right" id="pytorch-content-right">
          <div class="pytorch-right-menu" id="pytorch-right-menu">
            <div class="pytorch-side-scroll" id="pytorch-side-scroll-right">
              <ul>
<li><a class="reference internal" href="#">Basic Concepts</a><ul>
<li><a class="reference internal" href="#markov-decision-process-mdp">Markov Decision Process/MDP</a></li>
<li><a class="reference internal" href="#state-spaces">State Spaces</a></li>
<li><a class="reference internal" href="#action-spaces">Action Spaces</a></li>
<li><a class="reference internal" href="#policy">Policy</a></li>
<li><a class="reference internal" href="#trajectory">Trajectory</a></li>
<li><a class="reference internal" href="#return-and-reward">Return and reward</a></li>
<li><a class="reference internal" href="#rl-optimization-problem">RL optimization problem</a></li>
<li><a class="reference internal" href="#value-functions">Value functions</a></li>
<li><a class="reference internal" href="#policy-gradients">Policy Gradients</a></li>
<li><a class="reference internal" href="#actor-critic">Actor Critic</a></li>
<li><a class="reference internal" href="#model-based-rl">Model-based RL</a></li>
<li><a class="reference internal" href="#q-a">Q&amp;A</a></li>
</ul>
</li>
</ul>

            </div>
          </div>
        </div>
    </section>
  </div>

  


  

  
  <script type="text/javascript" id="documentation_options" data-url_root="../"
    src="../_static/documentation_options.js"></script>
  <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
  <script src="../_static/jquery.js"></script>
  <script src="../_static/underscore.js"></script>
  <script src="../_static/doctools.js"></script>
  <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  

  

  <script type="text/javascript" src="../_static/js/vendor/popper.min.js"></script>
  <script type="text/javascript" src="../_static/js/vendor/bootstrap.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/list.js/1.5.0/list.min.js"></script>
  <script type="text/javascript" src="../_static/js/theme.js"></script>

  <script type="text/javascript">
    jQuery(function () {
      SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

  <!-- Begin Footer -->

  <div class="container-fluid docs-tutorials-resources" id="docs-tutorials-resources">
  </div>

  <!-- End Footer -->

  <!-- Begin Mobile Menu -->

  <div class="mobile-main-menu">
    <div class="container-fluid">
      <div class="container">
        <div class="mobile-main-menu-header-container">
          <a class="header-logo" href="https://di-engine-docs.readthedocs.io/en/latest/" aria-label="OpenMMLab"></a>
          <a class="main-menu-close-button" href="#" data-behavior="close-mobile-menu"></a>
        </div>
      </div>
    </div>

    <div class="mobile-main-menu-links-container">
      <div class="main-menu">
        <ul>
          <li>
            <a href="https://github.com/opendilab/DI-engine" target="_blank">GitHub</a>
          </li>
      </div>
    </div>
  </div>

  <!-- End Mobile Menu -->

  <script type="text/javascript" src="../_static/js/vendor/anchor.min.js"></script>

  <script type="text/javascript">
    $(document).ready(function () {
      mobileMenu.bind();
      mobileTOC.bind();
      pytorchAnchors.bind();
      sideMenus.bind();
      scrollToAnchor.bind();
      highlightNavigation.bind();
      mainMenuDropdown.bind();
      filterTags.bind();

      // Add class to links that have code blocks, since we cannot create links in code blocks
      $("article.pytorch-article a span.pre").each(function (e) {
        $(this).closest("a").addClass("has-code");
      });
    })
  </script>
</body>

</html>