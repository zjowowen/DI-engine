

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>IMPALA &mdash; DI-engine 0.1.0 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="PPG" href="ppg.html" />
    <link rel="prev" title="ACER" href="acer.html" />
    <link href="../_static/css/style.css" rel="stylesheet" type="text/css">

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> DI-engine
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption" role="heading"><span class="caption-text">User Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../installation/index.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../quick_start/index.html">Quick Start</a></li>
<li class="toctree-l1"><a class="reference internal" href="../key_concept/index.html">Key Concept</a></li>
<li class="toctree-l1"><a class="reference internal" href="../intro_rl/index.html">Introduction to RL</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html">RL Algorithm Cheat Sheet</a></li>
<li class="toctree-l1"><a class="reference internal" href="../env_tutorial/index.html">RL Environments Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../distributed/index.html">Distributed</a></li>
<li class="toctree-l1"><a class="reference internal" href="../best_practice/index.html">Best Practice</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api_doc/index.html">API Doc</a></li>
<li class="toctree-l1"><a class="reference internal" href="../faq/index.html">FAQ</a></li>
<li class="toctree-l1"><a class="reference internal" href="../feature/index.html">Feature</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Developer Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../guide/index.html">Developer Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorial_dev/index.html">Tutorial-Developer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../architecture/index.html">Architecture Design</a></li>
<li class="toctree-l1"><a class="reference internal" href="../specification/index.html">Middleware code specification</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">DI-engine</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">RL Algorithm Cheat Sheet</a> &raquo;</li>
        
      <li>IMPALA</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/hands_on/impala.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <section id="impala">
<h1>IMPALA<a class="headerlink" href="#impala" title="Permalink to this headline">¶</a></h1>
<section id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p>IMPALA, or the Importance Weighted Actor Learner Architecture, is an off-policy actor-critic framework that
decouples data collecting from learning and optimizes policy from experience trajectories using off-policy correction V-trace. This method is firstly
introduced in <a class="reference external" href="https://arxiv.org/abs/1802.01561">IMPALA: Scalable Distributed Deep-RL with Importance Weighted Actor-Learner Architectures</a>.</p>
</section>
<section id="quick-facts">
<h2>Quick Facts<a class="headerlink" href="#quick-facts" title="Permalink to this headline">¶</a></h2>
<ol class="arabic simple">
<li><p>IMPALA is a <strong>model-free</strong> and <strong>off-policy</strong> RL algorithm.</p></li>
<li><p>IMPALA can support both <strong>discrete</strong> action spaces and <strong>continuous</strong> action spaces.</p></li>
<li><p>IMPALA is an actor-critic RL algorithm with value network, which optimizes actor network and critic (value) network, respectively.</p></li>
<li><p>IMPALA can take advantage of the old off-policy data with corresponding <strong>off-policy correction</strong>  to stabilize learning.</p></li>
<li><p>IMPALA decouples data collecting from learning. Collectors in IMPALA will not compute value or advantage.</p></li>
<li><p>IMPALA is a <strong>distributed RL architecture</strong> with classic actor-learner paradigm.</p></li>
</ol>
</section>
<section id="key-equations">
<h2>Key Equations<a class="headerlink" href="#key-equations" title="Permalink to this headline">¶</a></h2>
<p>Loss used in IMPALA is similar to that in PPO, A2C and other value function actor-critic models. All of them come from <code class="docutils literal notranslate"><span class="pre">policy_loss</span></code>,<code class="docutils literal notranslate"><span class="pre">value_loss</span></code> and <code class="docutils literal notranslate"><span class="pre">entropy_loss</span></code>, with respect to some carefully chosen weights, i.e.:</p>
<div class="math notranslate nohighlight">
\[loss_{total} = loss_{policy} + w_{value} * loss_{value} + w_{entropy} * loss_{entropy}\]</div>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>NOTATION AND CONVENTIONS:</p>
<p><span class="math notranslate nohighlight">\(\pi_{\phi}\)</span>: current training policy parameterized by <span class="math notranslate nohighlight">\(\phi\)</span>.</p>
<p><span class="math notranslate nohighlight">\(V_\theta\)</span>: value function parameterized by <span class="math notranslate nohighlight">\(\theta\)</span>.</p>
<p><span class="math notranslate nohighlight">\(\mu\)</span>: older policy which generates trajectories in replay buffer.</p>
</div>
<p>At the training time <span class="math notranslate nohighlight">\(t\)</span>, given transition <span class="math notranslate nohighlight">\((x_t, a_t, x_{t+1}, r_t)\)</span>, the value function <span class="math notranslate nohighlight">\(V_\theta\)</span>
is learned through an <span class="math notranslate nohighlight">\(L_2\)</span> loss between the current value and a V-trace target value. The n-step V-trace target
at time s is defined as follows:</p>
<div class="math notranslate nohighlight">
\[v_s  \stackrel{def}{=} V(x_s) + \sum_{t=s}^{s+n-1} \gamma^{t-s} \big(\prod_{i=s}^{t-1} c_i\big)\delta_t V\]</div>
<p>where <span class="math notranslate nohighlight">\(\delta_t V \stackrel{def}{=}  \rho_t (r_t + \gamma V(x_{t+1}) - V(x_t))\)</span> is a temporal difference for <span class="math notranslate nohighlight">\(V\)</span>,
<span class="math notranslate nohighlight">\(\rho_t \stackrel{def}{=} \min\big(\bar{\rho}, \frac{\pi(a_t \vert x_t)}{\mu(a_t \vert x_t)}\big)\)</span>,
and <span class="math notranslate nohighlight">\(c_i \stackrel{def}{=}\min\big(\bar{c}, \frac{\pi(a_i \vert s_i)}{\mu(a_i \vert s_i)}\big)\)</span></p>
<p><span class="math notranslate nohighlight">\(\rho_t\)</span> and <span class="math notranslate nohighlight">\(c_i\)</span> are <code class="docutils literal notranslate"><span class="pre">truncated</span> <span class="pre">importance</span> <span class="pre">sampling</span> <span class="pre">(IS)</span> <span class="pre">weights</span></code>,
where <span class="math notranslate nohighlight">\(\bar{\rho}\)</span> and <span class="math notranslate nohighlight">\(\bar{c}\)</span> are two truncation constants with <span class="math notranslate nohighlight">\(\bar{\rho} \geq \bar{c}\)</span>.</p>
<p>The product of <span class="math notranslate nohighlight">\(c_s, \dots, c_{t-1}\)</span> measures how much a temporal difference <span class="math notranslate nohighlight">\(\delta_t V\)</span> observed at time
<span class="math notranslate nohighlight">\(t\)</span> impacts the update of the value function at a previous time <span class="math notranslate nohighlight">\(s\)</span> . In the on-policy case, we have <span class="math notranslate nohighlight">\(\rho_t=1\)</span>
and <span class="math notranslate nohighlight">\(c_i=1\)</span> (assuming <span class="math notranslate nohighlight">\(\bar{c} \geq 1)\)</span> and therefore the V-trace target becomes on-policy n-step Bellman
target.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><span class="math notranslate nohighlight">\(\bar{\rho}\)</span> impacts the fixed-point of the value function we converge to, and <span class="math notranslate nohighlight">\(\bar{c}\)</span> impacts the speed
of convergence.</p>
<p>When <span class="math notranslate nohighlight">\(\bar{\rho} =\infty\)</span> (untruncated), v-trace value function will converge to the value
function of the target policy <span class="math notranslate nohighlight">\(V_\pi\)</span>;</p>
<p>When <span class="math notranslate nohighlight">\(\bar{\rho}\)</span> is close to 0, we evaluate the value function
of the behavior policy <span class="math notranslate nohighlight">\(V_\mu\)</span>; when in-between, we evaluate a policy between <span class="math notranslate nohighlight">\(\pi\)</span> and <span class="math notranslate nohighlight">\(\mu\)</span>.</p>
</div>
<p>Therefore, loss functions are</p>
<div class="math notranslate nohighlight">
\[\begin{split}loss_{value} &amp;= (v_s - V_\theta(x_s))^2 \\
loss_{policy} &amp;= -\rho_s \log \pi_\phi(a_s \vert x_s)  \big(r_s + \gamma v_{s+1} - V_\theta(x_s)\big) \\
loss_{entropy} &amp;= -H(\pi_\phi) = \sum_a \pi_\phi(a\vert x_s)\log \pi_\phi(a\vert x_s)\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(H(\pi_{\phi})\)</span>, entropy of policy <span class="math notranslate nohighlight">\(\phi\)</span>, is a bonus to encourage exploration.</p>
<p>Value function parameter is updated in the direction of:</p>
<div class="math notranslate nohighlight">
\[\Delta\theta = w_{value} (v_s - V_\theta(x_s))\nabla_\theta V_\theta(x_s)\]</div>
<p>Policy parameter <span class="math notranslate nohighlight">\(\phi\)</span> is updated through policy gradient,</p>
<div class="math notranslate nohighlight">
\[\begin{split}\Delta \phi &amp;= \rho_s \nabla_\phi \log \pi_\phi(a_s \vert x_s) \big(r_s + \gamma v_{s+1}- V_\theta(x_s)\big)\\
            &amp;- w_{entropy} \nabla_\phi \sum_a \pi_\phi(a\vert x_s)\log \pi_\phi(a\vert x_s)\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(r_s + \gamma v_{s+1}\)</span> is the v-trace advantage, which is estimated Q value subtracted by a state-dependent baseline <span class="math notranslate nohighlight">\(V_\theta(x_s)\)</span>.</p>
</section>
<section id="key-graphs">
<h2>Key Graphs<a class="headerlink" href="#key-graphs" title="Permalink to this headline">¶</a></h2>
<p>The following graph describes the distributed architecture in IMPALA original paper. However, our implication is a little different from
that in original paper.</p>
<a class="reference internal image-reference" href="../_images/IMPALA.png"><img alt="../_images/IMPALA.png" class="align-center" src="../_images/IMPALA.png" style="width: 503.29999999999995px; height: 375.2px;" /></a>
<p>For single learner, they use multiple actors/collectors to generate training data. While in our
setting, we use one collector which has multiple environments to increase data diversity.</p>
<p>For multiple learner, in original paper, different learners will have different actors with them. In other word, they
will have different ReplayBuffer. While in our setting, all of the learners, will share the same ReplayBuffer, and will
synchronize after each iteration.</p>
</section>
<section id="implementations">
<h2>Implementations<a class="headerlink" href="#implementations" title="Permalink to this headline">¶</a></h2>
<section id="config">
<h3>Config<a class="headerlink" href="#config" title="Permalink to this headline">¶</a></h3>
<p>The default config is defined as follows:</p>
<p>The network interface IMPALA used is defined as follows:</p>
</section>
<section id="data-processing">
<h3>Data Processing<a class="headerlink" href="#data-processing" title="Permalink to this headline">¶</a></h3>
<p>Usually, we hope to compute everything as a batch to improve efficiency. Especially, when computing vtrace, we
need all training sample (sequences of training data) have the same length. This is done in <code class="docutils literal notranslate"><span class="pre">policy._get_train_sample</span></code>.
Once we execute this function in collector, the length of samples will equal to <code class="docutils literal notranslate"><span class="pre">unroll_len</span></code> in config. For details, please
refer to doc of <code class="docutils literal notranslate"><span class="pre">ding.rl_utils.adder</span></code>.</p>
<div class="highlight-python notranslate" id="ref2other"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">_get_train_sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]:</span>
    <span class="k">return</span> <span class="n">get_train_sample</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_unroll_len</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">get_train_sample</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]],</span> <span class="n">unroll_len</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">last_fn_type</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;last&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Overview:</span>
<span class="sd">        Process raw traj data by updating keys [&#39;next_obs&#39;, &#39;reward&#39;, &#39;done&#39;] in data&#39;s dict element.</span>
<span class="sd">        If ``unroll_len`` equals to 1, which means no process is needed, can directly return ``data``.</span>
<span class="sd">        Otherwise, ``data`` will be split according to ``self._unroll_len``, process residual part according to</span>
<span class="sd">        ``last_fn_type`` and call ``lists_to_dicts`` to form sampled training data.</span>
<span class="sd">    Arguments:</span>
<span class="sd">        - data (:obj:`List[Dict[str, Any]]`): transitions list, each element is a transition dict</span>
<span class="sd">    Returns:</span>
<span class="sd">        - data (:obj:`List[Dict[str, Any]]`): transitions list processed after unrolling</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">unroll_len</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">data</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># cut data into pieces whose length is unroll_len</span>
        <span class="n">split_data</span><span class="p">,</span> <span class="n">residual</span> <span class="o">=</span> <span class="n">list_split</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_unroll_len</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">null_padding</span><span class="p">():</span>
            <span class="n">template</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">residual</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">template</span><span class="p">[</span><span class="s1">&#39;done&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">template</span><span class="p">[</span><span class="s1">&#39;reward&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">template</span><span class="p">[</span><span class="s1">&#39;reward&#39;</span><span class="p">])</span>
            <span class="k">if</span> <span class="s1">&#39;value_gamma&#39;</span> <span class="ow">in</span> <span class="n">template</span><span class="p">:</span>
                <span class="n">template</span><span class="p">[</span><span class="s1">&#39;value_gamma&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.</span>
            <span class="n">null_data</span> <span class="o">=</span> <span class="p">[</span><span class="bp">cls</span><span class="o">.</span><span class="n">_get_null_transition</span><span class="p">(</span><span class="n">template</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">miss_num</span><span class="p">)]</span>
            <span class="k">return</span> <span class="n">null_data</span>

        <span class="k">if</span> <span class="n">residual</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">miss_num</span> <span class="o">=</span> <span class="n">unroll_len</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">residual</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">last_fn_type</span> <span class="o">==</span> <span class="s1">&#39;drop&#39;</span><span class="p">:</span>
                <span class="c1"># drop the residual part</span>
                <span class="k">pass</span>
            <span class="k">elif</span> <span class="n">last_fn_type</span> <span class="o">==</span> <span class="s1">&#39;last&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">split_data</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># copy last datas from split_data&#39;s last element, and insert in front of residual</span>
                    <span class="n">last_data</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">split_data</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="n">miss_num</span><span class="p">:])</span>
                    <span class="n">split_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">last_data</span> <span class="o">+</span> <span class="n">residual</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># get null transitions using ``null_padding``, and insert behind residual</span>
                    <span class="n">null_data</span> <span class="o">=</span> <span class="n">null_padding</span><span class="p">()</span>
                    <span class="n">split_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">residual</span> <span class="o">+</span> <span class="n">null_data</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">last_fn_type</span> <span class="o">==</span> <span class="s1">&#39;null_padding&#39;</span><span class="p">:</span>
                <span class="c1"># same to the case of &#39;last&#39; type and split_data is empty</span>
                <span class="n">null_data</span> <span class="o">=</span> <span class="n">null_padding</span><span class="p">()</span>
                <span class="n">split_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">residual</span> <span class="o">+</span> <span class="n">null_data</span><span class="p">)</span>
        <span class="c1"># collate unroll_len dicts according to keys</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">split_data</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">split_data</span> <span class="o">=</span> <span class="p">[</span><span class="n">lists_to_dicts</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">recursive</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">split_data</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">split_data</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In <code class="docutils literal notranslate"><span class="pre">get_train_sample</span></code>, we introduce three ways to cut trajectory data into same-length pieces (length equal
to <code class="docutils literal notranslate"><span class="pre">unroll_len</span></code>).</p>
<p>1. The first one is <code class="docutils literal notranslate"><span class="pre">drop</span></code>, this means after splitting trajectory data into small pieces, we simply throw away those
with length smaller than <code class="docutils literal notranslate"><span class="pre">unroll_len</span></code>. This method is kind of naive and usually is not a good choice. Since in
Reinforcement Learning, the last few data in an episode is usually very important, we can’t just throw away them.</p>
<p>2. The second method is <code class="docutils literal notranslate"><span class="pre">last</span></code>, which means if the total length trajectory is smaller than <code class="docutils literal notranslate"><span class="pre">unroll_len</span></code>,
we will use zero padding. Else, we will use data from previous piece to pad residual piece. This method is set as
default and recommended.</p>
<ol class="arabic simple" start="3">
<li><p>The last method <code class="docutils literal notranslate"><span class="pre">null_padding</span></code> is just zero padding, which is not vert efficient since many data will be <code class="docutils literal notranslate"><span class="pre">null</span></code>.</p></li>
</ol>
</div>
</section>
<section id="optimization">
<h3>Optimization<a class="headerlink" href="#optimization" title="Permalink to this headline">¶</a></h3>
<p>Now, we introduce the computation of <code class="docutils literal notranslate"><span class="pre">vtrace-value</span></code>.
First, we use the following functions to compute importance_weights.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">compute_importance_weights</span><span class="p">(</span><span class="n">target_output</span><span class="p">,</span> <span class="n">behaviour_output</span><span class="p">,</span> <span class="n">action</span><span class="p">,</span> <span class="n">requires_grad</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Shapes:</span>
<span class="sd">        - target_output (:obj:`torch.FloatTensor`): :math:`(T, B, N)`, where T is timestep, B is batch size and\</span>
<span class="sd">            N is action dim</span>
<span class="sd">        - behaviour_output (:obj:`torch.FloatTensor`): :math:`(T, B, N)`</span>
<span class="sd">        - action (:obj:`torch.LongTensor`): :math:`(T, B)`</span>
<span class="sd">        - rhos (:obj:`torch.FloatTensor`): :math:`(T, B)`</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">grad_context</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">enable_grad</span><span class="p">()</span> <span class="k">if</span> <span class="n">requires_grad</span> <span class="k">else</span> <span class="n">torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">()</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">action</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">)</span>
    <span class="n">device</span> <span class="o">=</span> <span class="n">action</span><span class="o">.</span><span class="n">device</span>

    <span class="k">with</span> <span class="n">grad_context</span><span class="p">:</span>
        <span class="n">dist_target</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">distributions</span><span class="o">.</span><span class="n">Categorical</span><span class="p">(</span><span class="n">logits</span><span class="o">=</span><span class="n">target_output</span><span class="p">)</span>
        <span class="n">dist_behaviour</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">distributions</span><span class="o">.</span><span class="n">Categorical</span><span class="p">(</span><span class="n">logits</span><span class="o">=</span><span class="n">behaviour_output</span><span class="p">)</span>
        <span class="n">rhos</span> <span class="o">=</span> <span class="n">dist_target</span><span class="o">.</span><span class="n">log_prob</span><span class="p">(</span><span class="n">action</span><span class="p">)</span> <span class="o">-</span> <span class="n">dist_behaviour</span><span class="o">.</span><span class="n">log_prob</span><span class="p">(</span><span class="n">action</span><span class="p">)</span>
        <span class="n">rhos</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">rhos</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">rhos</span>
</pre></div>
</div>
<p>After that, we clip importance weights based on constant <span class="math notranslate nohighlight">\(\rho\)</span> and <span class="math notranslate nohighlight">\(c\)</span> to get clipped_rhos, clipped_cs.
Then we can compute vtrace value according to the following function. Notice, here bootstrap_values are just
value function <span class="math notranslate nohighlight">\(V(x_s)\)</span> in vtrace definition.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">vtrace_nstep_return</span><span class="p">(</span><span class="n">clipped_rhos</span><span class="p">,</span> <span class="n">clipped_cs</span><span class="p">,</span> <span class="n">reward</span><span class="p">,</span> <span class="n">bootstrap_values</span><span class="p">,</span> <span class="n">gamma</span><span class="o">=</span><span class="mf">0.99</span><span class="p">,</span> <span class="n">lambda_</span><span class="o">=</span><span class="mf">0.95</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Shapes:</span>
<span class="sd">        - clipped_rhos (:obj:`torch.FloatTensor`): :math:`(T, B)`, where T is timestep, B is batch size</span>
<span class="sd">        - clipped_cs (:obj:`torch.FloatTensor`): :math:`(T, B)`</span>
<span class="sd">        - reward: (:obj:`torch.FloatTensor`): :math:`(T, B)`</span>
<span class="sd">        - bootstrap_values (:obj:`torch.FloatTensor`): :math:`(T+1, B)`</span>
<span class="sd">        - vtrace_return (:obj:`torch.FloatTensor`):  :math:`(T, B)`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">deltas</span> <span class="o">=</span> <span class="n">clipped_rhos</span> <span class="o">*</span> <span class="p">(</span><span class="n">reward</span> <span class="o">+</span> <span class="n">gamma</span> <span class="o">*</span> <span class="n">bootstrap_values</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">bootstrap_values</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">factor</span> <span class="o">=</span> <span class="n">gamma</span> <span class="o">*</span> <span class="n">lambda_</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">bootstrap_values</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>
    <span class="n">vtrace_item</span> <span class="o">=</span> <span class="mf">0.</span>
    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">reward</span><span class="o">.</span><span class="n">size</span><span class="p">()[</span><span class="mi">0</span><span class="p">])):</span>
        <span class="n">vtrace_item</span> <span class="o">=</span> <span class="n">deltas</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">+</span> <span class="n">factor</span> <span class="o">*</span> <span class="n">clipped_cs</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">*</span> <span class="n">vtrace_item</span>
        <span class="n">result</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">+=</span> <span class="n">vtrace_item</span>
    <span class="k">return</span> <span class="n">result</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>1. Bootstrap_values in this part need to have size (T+1,B), where T is timestep, B is batch size. The reason is that
we need a sequence of training data with same-length vtrace value (this length is just the <code class="docutils literal notranslate"><span class="pre">unroll_len</span></code> in config).
And in order to compute the last vtrace value in the sequence, we need at least one more target value. This is
done using the next obs of the last transition in training data sequence.</p>
<p>2. Here we introduce a parameter <code class="docutils literal notranslate"><span class="pre">lambda_</span></code>, following the implementation in AlphaStar. The parameter, between 0
and 1, can give a subtle control on vtrace off-policy correction. Usually, we will choose this parameter close to 1.</p>
</div>
<p>Once we get vtrace value, or <code class="docutils literal notranslate"><span class="pre">vtrace_nstep_return</span></code>, the computation of loss functions are straightforward. The whole
process is as follows.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">vtrace_advantage</span><span class="p">(</span><span class="n">clipped_pg_rhos</span><span class="p">,</span> <span class="n">reward</span><span class="p">,</span> <span class="n">return_</span><span class="p">,</span> <span class="n">bootstrap_values</span><span class="p">,</span> <span class="n">gamma</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Shapes:</span>
<span class="sd">        - clipped_pg_rhos (:obj:`torch.FloatTensor`): :math:`(T, B)`, where T is timestep, B is batch size</span>
<span class="sd">        - reward: (:obj:`torch.FloatTensor`): :math:`(T, B)`</span>
<span class="sd">        - return_ (:obj:`torch.FloatTensor`):  :math:`(T, B)`</span>
<span class="sd">        - bootstrap_values (:obj:`torch.FloatTensor`): :math:`(T, B)`</span>
<span class="sd">        - vtrace_advantage (:obj:`torch.FloatTensor`):  :math:`(T, B)`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">clipped_pg_rhos</span> <span class="o">*</span> <span class="p">(</span><span class="n">reward</span> <span class="o">+</span> <span class="n">gamma</span> <span class="o">*</span> <span class="n">return_</span> <span class="o">-</span> <span class="n">bootstrap_values</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">vtrace_error</span><span class="p">(</span>
        <span class="n">data</span><span class="p">:</span> <span class="n">namedtuple</span><span class="p">,</span>
        <span class="n">gamma</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.99</span><span class="p">,</span>
        <span class="n">lambda_</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.95</span><span class="p">,</span>
        <span class="n">rho_clip_ratio</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
        <span class="n">c_clip_ratio</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
        <span class="n">rho_pg_clip_ratio</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Shapes:</span>
<span class="sd">        - target_output (:obj:`torch.FloatTensor`): :math:`(T, B, N)`, where T is timestep, B is batch size and\</span>
<span class="sd">            N is action dim</span>
<span class="sd">        - behaviour_output (:obj:`torch.FloatTensor`): :math:`(T, B, N)`</span>
<span class="sd">        - action (:obj:`torch.LongTensor`): :math:`(T, B)`</span>
<span class="sd">        - value (:obj:`torch.FloatTensor`): :math:`(T+1, B)`</span>
<span class="sd">        - reward (:obj:`torch.LongTensor`): :math:`(T, B)`</span>
<span class="sd">        - weight (:obj:`torch.LongTensor`): :math:`(T, B)`</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">target_output</span><span class="p">,</span> <span class="n">behaviour_output</span><span class="p">,</span> <span class="n">action</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">reward</span><span class="p">,</span> <span class="n">weight</span> <span class="o">=</span> <span class="n">data</span>
    <span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">():</span>
        <span class="n">IS</span> <span class="o">=</span> <span class="n">compute_importance_weights</span><span class="p">(</span><span class="n">target_output</span><span class="p">,</span> <span class="n">behaviour_output</span><span class="p">,</span> <span class="n">action</span><span class="p">)</span>
        <span class="n">rhos</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">clamp</span><span class="p">(</span><span class="n">IS</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="n">rho_clip_ratio</span><span class="p">)</span>
        <span class="n">cs</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">clamp</span><span class="p">(</span><span class="n">IS</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="n">c_clip_ratio</span><span class="p">)</span>
        <span class="n">return_</span> <span class="o">=</span> <span class="n">vtrace_nstep_return</span><span class="p">(</span><span class="n">rhos</span><span class="p">,</span> <span class="n">cs</span><span class="p">,</span> <span class="n">reward</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">lambda_</span><span class="p">)</span>
        <span class="n">pg_rhos</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">clamp</span><span class="p">(</span><span class="n">IS</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="n">rho_pg_clip_ratio</span><span class="p">)</span>
        <span class="n">return_t_plus_1</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">([</span><span class="n">return_</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">value</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">:]],</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">adv</span> <span class="o">=</span> <span class="n">vtrace_advantage</span><span class="p">(</span><span class="n">pg_rhos</span><span class="p">,</span> <span class="n">reward</span><span class="p">,</span> <span class="n">return_t_plus_1</span><span class="p">,</span> <span class="n">value</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">gamma</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">weight</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">weight</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">reward</span><span class="p">)</span>
    <span class="n">dist_target</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">distributions</span><span class="o">.</span><span class="n">Categorical</span><span class="p">(</span><span class="n">logits</span><span class="o">=</span><span class="n">target_output</span><span class="p">)</span>
    <span class="n">pg_loss</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">dist_target</span><span class="o">.</span><span class="n">log_prob</span><span class="p">(</span><span class="n">action</span><span class="p">)</span> <span class="o">*</span> <span class="n">adv</span> <span class="o">*</span> <span class="n">weight</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
    <span class="n">value_loss</span> <span class="o">=</span> <span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">mse_loss</span><span class="p">(</span><span class="n">value</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">return_</span><span class="p">,</span> <span class="n">reduction</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">)</span> <span class="o">*</span> <span class="n">weight</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
    <span class="n">entropy_loss</span> <span class="o">=</span> <span class="p">(</span><span class="n">dist_target</span><span class="o">.</span><span class="n">entropy</span><span class="p">()</span> <span class="o">*</span> <span class="n">weight</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">vtrace_loss</span><span class="p">(</span><span class="n">pg_loss</span><span class="p">,</span> <span class="n">value_loss</span><span class="p">,</span> <span class="n">entropy_loss</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ol class="arabic simple">
<li><p>The shape of value in input data should be (T+1, B), the reason is same as above Note.</p></li>
<li><p>Here we introduce a parameter <code class="docutils literal notranslate"><span class="pre">rho_pg_clip_ratio</span></code>, following the implementation in AlphaStar. This parameter, can give a subtle control on vtrace advantage. Usually, we will choose this parameter just same as rho_clip_ratio.</p></li>
</ol>
</div>
</section>
</section>
<section id="benchmark">
<h2>Benchmark<a class="headerlink" href="#benchmark" title="Permalink to this headline">¶</a></h2>
<table class="colwidths-given docutils align-default" id="id1">
<caption><span class="caption-text">Benchmark and comparison of IMPALA algorithm</span><a class="headerlink" href="#id1" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 25%" />
<col style="width: 15%" />
<col style="width: 30%" />
<col style="width: 15%" />
<col style="width: 15%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>environment</p></th>
<th class="head"><p>best mean reward</p></th>
<th class="head"><p>evaluation results</p></th>
<th class="head"><p>config link</p></th>
<th class="head"><p>comparison</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><div class="line-block">
<div class="line">Pong</div>
<div class="line">(PongNoFrameskip-v4)</div>
</div>
</td>
<td><p>20</p></td>
<td><img alt="hands_on/images/benchmark/IMPALA_pong.png" src="hands_on/images/benchmark/IMPALA_pong.png" />
</td>
<td><p><a class="reference external" href="https://github.com/opendilab/DI-engine/blob/main/dizoo/atari/config/serial/pong/pong_IMPALA_config.py">config_link_p</a></p></td>
<td><div class="line-block">
<div class="line">IMPALA paper shallow 200M (20.4)</div>
</div>
</td>
</tr>
<tr class="row-odd"><td><div class="line-block">
<div class="line">Qbert</div>
<div class="line">(QbertNoFrameskip-v4)</div>
</div>
</td>
<td><p>13175</p></td>
<td><img alt="hands_on/images/benchmark/IMPALA_qbert.png" src="hands_on/images/benchmark/IMPALA_qbert.png" />
</td>
<td><p><a class="reference external" href="https://github.com/opendilab/DI-engine/blob/main/dizoo/atari/config/serial/qbert/qbert_IMPALA_config.py">config_link_q</a></p></td>
<td><div class="line-block">
<div class="line">IMPALA paper shallow 200M (18901)</div>
</div>
</td>
</tr>
<tr class="row-even"><td><div class="line-block">
<div class="line">SpaceInvaders</div>
<div class="line">(SpaceInvadersNoFrame skip-v4)</div>
</div>
</td>
<td><p>977</p></td>
<td><img alt="hands_on/images/benchmark/IMPALA_spaceinvaders.png" src="hands_on/images/benchmark/IMPALA_spaceinvaders.png" />
</td>
<td><p><a class="reference external" href="https://github.com/opendilab/DI-engine/blob/main/dizoo/atari/config/serial/spaceinvaders/spaceinvaders_IMPALA_config.py">config_link_s</a></p></td>
<td><div class="line-block">
<div class="line">IMPALA paper shallow 200M (1726)</div>
</div>
</td>
</tr>
</tbody>
</table>
<p>P.S.：</p>
<ol class="arabic simple">
<li><p>The above results are obtained by running the same configuration on five different random seeds (0, 1, 2, 3, 4)</p></li>
<li><p>For the discrete action space algorithm like IMPALA, the Atari environment set is generally used for testing (including sub-environments Pong), and Atari environment is generally evaluated by the highest mean reward training 10M <code class="docutils literal notranslate"><span class="pre">env_step</span></code>. For more details about Atari, please refer to <a class="reference external" href="../env_tutorial/atari.html">Atari Env Tutorial</a> .</p></li>
</ol>
</section>
<section id="reference">
<h2>Reference<a class="headerlink" href="#reference" title="Permalink to this headline">¶</a></h2>
<p>Lasse Espeholt, Hubert Soyer, Remi Munos, Karen Simonyan, Volodymir Mnih, Tom Ward, Yotam Doron, Vlad Firoiu, Tim Harley, Iain Dunning, Shane Legg, Koray Kavukcuoglu: “IMPALA: Scalable Distributed Deep-RL with Importance Weighted Actor-Learner Architectures”, 2018; arXiv:1802.01561.  https://arxiv.org/abs/1802.01561</p>
</section>
<section id="other-public-implementations">
<h2>Other Public Implementations<a class="headerlink" href="#other-public-implementations" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p>[Official](<a class="reference external" href="https://github.com/deepmind/scalable_agent">https://github.com/deepmind/scalable_agent</a>)</p></li>
<li><p>[Facebook torchbeast](<a class="reference external" href="https://github.com/facebookresearch/torchbeast">https://github.com/facebookresearch/torchbeast</a>)</p></li>
</ul>
</section>
</section>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="ppg.html" class="btn btn-neutral float-right" title="PPG" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="acer.html" class="btn btn-neutral float-left" title="ACER" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2021, OpenDILab Contributors

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>